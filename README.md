# 顺序性消费

## Rabbitmq

https://www.rabbitmq.com/consumers.html#concurrency

消费者并发主要是客户端库的实现细节和应用配置的问题。大多数客户端库（例如.Java，.NET，Go，Erlang），消息投递被分发到一个处理全部异步消费者操作的线程池。这个池子通常有可控的并发度。

Java和.NET客户端保证，单通道的消息投递会以服务器接收的顺序被分发，从而不用考虑并发度。注意，一旦被分发，消息投递的并发处理在处理线程之间会产生一个竞态条件。

当消息投递被并发处理时，某些客户端（例如Bunny）和框架会选择将消费者调度池限制为一个单线程，从而避免竟态条件的产生。有些应用依赖严格的顺序性投递处理，因此必须使用值为1的并发度，或者在它们自己的代码里处理同步。能并发处理消息投递的应用能使用的并发度取决于可用的核心数。